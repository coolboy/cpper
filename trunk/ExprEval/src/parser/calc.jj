options{  JAVA_UNICODE_ESCAPE = true;  STATIC = false;  IGNORE_CASE = true;}PARSER_BEGIN(Calculator)package parser;import java.util.*;import java.io.*;import exceptions.*;public class Calculator{public static void main(String[]args)throws ExpressionException, ParseException{    try {      while (true){        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        Calculator parser = new Calculator();        System.out.println(parser.calculate(br.readLine()));      }    }    catch (IOException ex){      ex.printStackTrace();    }  }  public Calculator(){    this (new StringReader(" "));  }  private static final double TOLERANCE = 0.00001;  private Stack stack = new java.util.Stack();  public  boolean popBoolean()throws ClassCastException{    Boolean a = (Boolean)stack.pop();    return a.booleanValue();  }  public double popDouble()throws ClassCastException{    Double a = (Double)stack.pop();    return a.doubleValue();  }  public String calculate(String exp)throws   ParseException ,  	ExpressionException{  	if (exp != null)  	{  		exp = exp.trim();  		if (exp.isEmpty())  			throw new EmptyExpressionException();  	}else  	{  		throw new EmptyExpressionException();  	}	     this .ReInit(new StringReader(exp));    stack.clear();    try {	this .Expression();	} 	catch (ParseException ex) {		String img = ex.currentToken.image;		if (img == ")")			throw new MissingRightParenthesisException();		else if(img == "(")			throw new MissingLeftParenthesisException();		throw new  LexicalException();	}	catch (TokenMgrError err) {		throw new  LexicalException();	}    return stack.pop().toString();  }}PARSER_END(Calculator)/* 
 * Lexical definitions 
 */SKIP:/* Skip white space */{  " "  | "\t"  | "\r"  | "\f"}TOKEN:/* Boolean literals         */{  <TRUE:"true">  | <FALSE:"false">}TOKEN:/* Numeric and string literals */{  <INTEGER_LITERAL:(["0"-"9"])+>  | <FLOATING_POINT_LITERAL:(["0"-"9"])*"."(["0"-"9"])*>//  | <STRING_LITERAL:"\""((~["\"", "\\", "\n", "\r"])//  | ("\\"(["n", "t", "b", "r", "f", "\\", "'", "\""]//  | ["0"-"7"](["0"-"7"])?//  | ["0"-"3"]["0"-"7"]["0"-"7"])))*"\"">}TOKEN:/* Identifier */{  <IDENTIFIER:    "min"  | "max"  | "sin"  | "cos"  | "mix">//  <IDENTIFIER:(~["(", ")"])(["a"-"d","f"-"z"])+>}TOKEN:/* Parentheses and comma */{  <LPAREN:"(">  | <RPAREN:")">  | <COMMA:",">}TOKEN:/* Operators */{  <GT:">">  | <LT:"<">  | <EXCL:"!">  | <MI:"^">  | <EQ:"=">  | <LE:"<=">  | <GE:">=">  | <NE:"<>">  | <OR:"|">  | <AND:"&">  | <PLUS:"+">  | <MINUS:"-">  | <MULT:"*">  | <SLASH:"/">  | <SCI:"e">  | <THREEONE:"?">  | <THREETWO:":">}//优先级//低//高//或
void Expression()throws ExpressionException:{}{  AndExpression()(<OR>AndExpression(){    try {      boolean a = popBoolean();      boolean b = popBoolean();      stack.push(new Boolean(b || a));    }    catch (ClassCastException ex){    	throw new TypeMismatchedException();    }  }  )*(SelectFunciton())?}//三元运算符void SelectFunciton()throws ExpressionException:{  boolean bChoice = false;}{//true?1:2  <THREEONE>{    bChoice = popBoolean();  }  ArithmeticUnaryExpression()<THREETWO>ArithmeticUnaryExpression(){    if (bChoice){      stack.pop();    }  }}//和
void AndExpression()throws ExpressionException:{}{  EqComparisonExpression()(<AND>EqComparisonExpression(){    boolean a = false, b = false;    try {      a = popBoolean();      b = popBoolean();      stack.push(new Boolean(b && a));    }    catch (ClassCastException ex){    	throw new MissingOperandException();    }  }  )*}//相等
void EqComparisonExpression()throws ExpressionException:{  Token x = null;}{  /* comparing booleans is not permitted in this grammar*/ComparisonExpression()((x = <EQ>  | x = <NE>)ComparisonExpression(){    try {      double a = popDouble();      double b = popDouble();      if (x.kind == EQ){        if (Math.abs(a-b) <= TOLERANCE)stack.push(new Boolean(true));        else stack.push(new Boolean(false));      }      else if (x.kind == NE){        if (Math.abs(a-b)>TOLERANCE)stack.push(new Boolean(true));        else stack.push(new Boolean(false));      }    }    catch (ClassCastException ex){    	throw new MissingOperandException();    }  }  )*}//比较
void ComparisonExpression()throws ExpressionException:{  Token x = null;}{  AdditiveExpression()((x = <LT>  | x = <GT>  | x = <LE>  | x = <GE>)AdditiveExpression(){    try {      double a = popDouble();      double b = popDouble();      if (x.kind == LT)stack.push(new Boolean(b<a));      else if (x.kind == GT)stack.push(new Boolean(b>a));      else if (x.kind == LE)stack.push(new Boolean(b <= a));      else if (x.kind == GE)stack.push(new Boolean(b >= a));    }    catch (ClassCastException ex){    	throw new MissingOperandException();    }  }  )*}//加法+减法
void AdditiveExpression()throws ExpressionException:{  Token x = null;}{  MultiplicativeExpression()  ((x = <PLUS>| x = <MINUS>)  (MultiplicativeExpression()| x = <RPAREN>)  {  	if (x.kind == RPAREN)  		throw new MissingOperandException();  	    try {      double a = popDouble();      double b = popDouble();      if (x.kind == PLUS)stack.push(new Double(b+a));      else stack.push(new Double(b-a));    }    catch (ClassCastException ex){    	throw new TypeMismatchedException();    }  }  )*}//乘法+除法
void MultiplicativeExpression()throws ExpressionException:{  Token x = null;}{  MiExpression()((x = <MULT>  | x = <SLASH>)MiExpression(){    try {      double a = popDouble();      double b = popDouble();      if (x.kind == MULT)stack.push(new Double(b*a));      else {        if (a == 0){          throw new DividedByZeroException();        }        stack.push(new Double(b/a));      }    }    catch (ClassCastException ex){    	throw new MissingOperandException();    }  }  )*}//求幂void MiExpression()throws ExpressionException:{}{  ArithmeticUnaryExpression()((<MI>)ArithmeticUnaryExpression(){    try {      double a = popDouble();      double b = popDouble();      double tmp = b;      if (a>0)--a;      else b = 1;      if (a == 0){        stack.push(new Double(1));      }      else {        while (a != 0){          if (a>0){            b*=tmp;            --a;          }          else {            b/=tmp;            ++a;          }        }        stack.push(new Double(b));      }    }    catch (ClassCastException ex){    	throw new TypeMismatchedException();    }  }  )*}//正负数
void ArithmeticUnaryExpression()throws ExpressionException:{  Token x = null;}{  (x = <PLUS>  | x = <MINUS>)ArithmeticUnaryExpression(){    try {      double value = popDouble();      if (x.kind == PLUS)stack.push(new Double(value));      else stack.push(new Double(-1*value));    }    catch (ClassCastException ex){    	throw new MissingOperandException();    }  }  | BooleanUnaryExpression()}//取反
void BooleanUnaryExpression()throws ExpressionException:{  Token x = null;}{  (x = <EXCL>)ArithmeticUnaryExpression(){    try {      boolean value = popBoolean();      stack.push(new Boolean(!value));    }    catch (ClassCastException ex){    	throw new MissingOperandException();    }  }  | PrimitiveExpression()}void PrimitiveExpression()throws ExpressionException:{Token x = null;}{  Literal()  | LOOKAHEAD(2)Function()  | <IDENTIFIER>  |//  (x = <LPAREN>)//  {//  	if (x != null)//  		throw new MissingRightParenthesisException();//  }   (<LPAREN>Expression()<RPAREN>)  (x = <INTEGER_LITERAL>)?  {  	if (x != null)  		throw new MissingOperatorException();  }//  (x = <RPAREN>)//  {//  	if (x != null)//  		throw new MissingLeftParenthesisException();//  }}void Function()throws ExpressionException:{  int argCount;  String functionName;}{  <IDENTIFIER>{    functionName = token.image;  }  argCount = Arguments(){    double a = 0.0, b = 0.0, c = 0.0;    if (functionName.equalsIgnoreCase("min")){      if (argCount<2){		throw new MissingOperandException();      }      try {        a = popDouble();        b = popDouble();        a = Math.min(a, b);        if (argCount != 2){          while (argCount != 2){            c = Math.min(a, popDouble());            if (c<a)a = c;            --argCount;          }        }        else {          c = a;        }      }      catch (ClassCastException ex){        throw new ParseException();      }      stack.push(new Double(c));    }    else if (functionName.equalsIgnoreCase("max")){   	if (argCount<2){		throw new MissingOperandException();      }      try {        a = popDouble();        b = popDouble();        a = Math.max(a, b);        if (argCount != 2){          while (argCount != 2){            c = Math.max(a, popDouble());            if (c>a)a = c;            --argCount;          }        }        else {          c = a;        }      }      catch (ClassCastException ex){      	throw new TypeMismatchedException();      }      stack.push(new Double(c));    }    else if (functionName.equalsIgnoreCase("sin")){      if (argCount != 1)      	throw new FunctionCallException();      try {        a = popDouble();      }      catch (ClassCastException ex)      {      	throw new TypeMismatchedException();      }      stack.push(new Double(Math.sin(a)));    }    else if (functionName.equalsIgnoreCase("cos")){      if (argCount != 1)      	throw new FunctionCallException();      	      try {        a = popDouble();      }      catch (ClassCastException ex){      	throw new TypeMismatchedException();      }      stack.push(new Double(Math.cos(a)));    }    else     throw new IllegalIdentifierException();  }}//科学计数法后缀
void ScienceAppendix()throws ExpressionException:{  Token x = null;  Token y = null;}{  <SCI>//E | e
(y = <PLUS>  | y = <MINUS>)?//+ -
(x = <INTEGER_LITERAL>){    int eVal = Integer.parseInt(x.image);    double val = popDouble();    if (y == null || y.kind == PLUS){      while (eVal != 0){        val*=10;        --eVal;      }      stack.push(new Double(val));    }    else if (y.kind == MINUS){      while (eVal != 0){        val/=10;        --eVal;      }      stack.push(new Double(val));    }    else     	throw new IllegalDecimalException();  }}void Literal()throws ExpressionException:{Token x= null;}{  <INTEGER_LITERAL>{    stack.push(new Double(token.image));  }  (ScienceAppendix())?  | (x = <FLOATING_POINT_LITERAL>){  	if (x.image.charAt(0) == '.' ||  	x.image.endsWith("."))  		throw new IllegalDecimalException();    stack.push(new Double(token.image));  }  (ScienceAppendix())?//  | <STRING_LITERAL>{//    stack.push(trimQuotes(token.image));//  }  | BooleanLiteral()}void BooleanLiteral():{}{  <TRUE>{    stack.push(new Boolean(true));  }  | <FALSE>{    stack.push(new Boolean(false));  }}int Arguments()throws ExpressionException:{  int argCount = 0;}{  <LPAREN>[argCount = ArgumentList()]<RPAREN>{    return argCount;  }}int ArgumentList()throws ExpressionException:{  int argCount = 0;}{  Expression(){    argCount++;  }  (<COMMA>Expression(){    argCount++;  }  )*{    return argCount;  }}
