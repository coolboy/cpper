options{  JAVA_UNICODE_ESCAPE = true;  STATIC = false;  IGNORE_CASE = true;}PARSER_BEGIN(Calculator)package parser;
import java.util.*;import java.io.*;public class Calculator{  public static void main(String[]args)throws ParseException{    try {      while (true){        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        Calculator parser = new Calculator();        System.out.println(parser.calculate(br.readLine()));      }    }    catch (IOException ex){      System.out.println("IO Exception");      ex.printStackTrace();    }  }    public Calculator()  {  	this (new StringReader(" "));  }    private static final double TOLERANCE = 0.00001;  private static Stack stack = new java.util.Stack();  public static boolean popBoolean()throws ClassCastException{    Boolean a = (Boolean)stack.pop();    if (a == null)throw new ClassCastException();    return a.booleanValue();  }  public static double popDouble()throws ClassCastException{    Double a = (Double)stack.pop();    if (a == null)throw new ClassCastException();    return a.doubleValue();  }  public double calculate(String exp)throws ParseException{    this .ReInit(new StringReader(exp));    stack.clear();    this .Expression();    return ((Double)stack.pop()).doubleValue();  }  public static String trimQuotes(String s){    // removes leading and trailing quote character from string literal     return s.substring(1, s.length()-1);  }}PARSER_END(Calculator)/* 
 * Lexical definitions 
 */SKIP:/* Skip white space */{  " "  | "\t"  | "\r"  | "\f"}TOKEN:/* Boolean literals         */{  <TRUE:"true">  | <FALSE:"false">}TOKEN:/* Numeric and string literals */{  <INTEGER_LITERAL:(["0"-"9"])+>  | <FLOATING_POINT_LITERAL:(["0"-"9"])+"."(["0"-"9"])+>  | <STRING_LITERAL:"\""((~["\"", "\\", "\n", "\r"])  | ("\\"(["n", "t", "b", "r", "f", "\\", "'", "\""]  | ["0"-"7"](["0"-"7"])?  | ["0"-"3"]["0"-"7"]["0"-"7"])))*"\"">}TOKEN:/* Identifier */{  <IDENTIFIER:"min"  | "max"  | "sin"  | "cos">}TOKEN:/* Parentheses and comma */{  <LPAREN:"(">  | <RPAREN:")">  | <COMMA:",">}TOKEN:/* Operators */{  <GT:">">  | <LT:"<">  | <EXCL:"!">  | <MI:"^">  | <EQ:"=">  | <LE:"<=">  | <GE:">=">  | <NE:"<>">  | <OR:"|">  | <AND:"&">  | <PLUS:"+">  | <MINUS:"-">  | <MULT:"*">  | <SLASH:"/">  | <SCI:"e">  | <THREEONE:"?">  | <THREETWO:":">}//或
void Expression():{}{  AndExpression()(<OR>AndExpression(){    try {      boolean a = popBoolean();      boolean b = popBoolean();      stack.push(new Boolean(b || a));    }    catch (ClassCastException ex){      System.out.println("Non boolean operand supplied for <OR> operator");      throw new ParseException();    }  }  )*}void SelectFunciton():{  boolean bChoice = false;}{  <THREEONE>{    bChoice = popBoolean();  }  ArithmeticUnaryExpression()<THREETWO>ArithmeticUnaryExpression(){    if (bChoice){      stack.pop();    }    else {      Object obj = stack.pop();      stack.pop();      stack.push(obj);    }  }}//和
void AndExpression():{}{  EqComparisonExpression()(<AND>EqComparisonExpression(){    try {      boolean a = popBoolean();      boolean b = popBoolean();      stack.push(new Boolean(b && a));    }    catch (ClassCastException ex){      System.out.println("Non boolean operand supplied for <AND> operator");      throw new ParseException();    }  }  )*}//相等
void EqComparisonExpression():{  Token x = null;}{  /* comparing booleans is not permitted in this grammar*/ComparisonExpression()((x = <EQ>  | x = <NE>)ComparisonExpression(){    try {      double a = popDouble();      double b = popDouble();      if (x.kind == EQ){        if (Math.abs(a-b) <= TOLERANCE)stack.push(new Boolean(true));        else stack.push(new Boolean(false));      }      else if (x.kind == NE){        if (Math.abs(a-b)>TOLERANCE)stack.push(new Boolean(true));        else stack.push(new Boolean(false));      }    }    catch (ClassCastException ex){      System.out.println("Non numeric operand supplied for comparative "+"operator <EQ> or <NE>");      throw new ParseException();    }  }  )*}//比较
void ComparisonExpression():{  Token x = null;}{  AdditiveExpression()((x = <LT>  | x = <GT>  | x = <LE>  | x = <GE>)AdditiveExpression(){    try {      double a = popDouble();      double b = popDouble();      if (x.kind == LT)stack.push(new Boolean(b<a));      else if (x.kind == GT)stack.push(new Boolean(b>a));      else if (x.kind == LE)stack.push(new Boolean(b <= a));      else if (x.kind == GE)stack.push(new Boolean(b >= a));    }    catch (ClassCastException ex){      System.out.println("Non numeric operand supplied for relational "+"operator (<, <=, >, >=)");      throw new ParseException();    }  }  )*(SelectFunciton())?}//加法+减法
void AdditiveExpression():{  Token x = null;}{  MultiplicativeExpression()  ((x = <PLUS> | x = <MINUS>)  MultiplicativeExpression(){    try {      double a = popDouble();      double b = popDouble();      if (x.kind == PLUS)stack.push(new Double(b+a));      else stack.push(new Double(b-a));    }    catch (ClassCastException ex){      System.out.println("Non numeric operand supplied for + or - operator");      throw new ParseException();    }  }  )*}//乘法+除法
void MultiplicativeExpression():{  Token x = null;}{  MiExpression()((x = <MULT>  | x = <SLASH>)MiExpression(){    try {      double a = popDouble();      double b = popDouble();      if (x.kind == MULT)stack.push(new Double(b*a));      else stack.push(new Double(b/a));    }    catch (ClassCastException ex){      System.out.println("Non numeric operand supplied for * or / operator");      throw new ParseException();    }  }  )*}//求幂void MiExpression():{}{  ArithmeticUnaryExpression()((<MI>)ArithmeticUnaryExpression(){    try {      double a = popDouble();      double b = popDouble();      double tmp = b;      if (a>0)--a;      else b = 1;      if (a == 0){        stack.push(new Double(1));      }      else {        while (a != 0){          if (a>0){            b*=tmp;            --a;          }          else {            b/=tmp;            ++a;          }        }        stack.push(new Double(b));      }    }    catch (ClassCastException ex){      System.out.println("Non numeric operand supplied for ^ operator");      throw new ParseException();    }  }  )*}//正负数
void ArithmeticUnaryExpression():{  Token x = null;}{  (x = <PLUS>  | x = <MINUS>)ArithmeticUnaryExpression(){    try {      double value = popDouble();      if (x.kind == PLUS)stack.push(new Double(value));      else stack.push(new Double(-1*value));    }    catch (ClassCastException ex){      System.out.println("Non numeric operand supplied for unary + or ~ operator");      throw new ParseException();    }  }  | BooleanUnaryExpression()}//取反
void BooleanUnaryExpression():{  Token x = null;}{  (x = <EXCL>)ArithmeticUnaryExpression(){    try {      boolean value = popBoolean();      stack.push(new Boolean(!value));    }    catch (ClassCastException ex){      System.out.println("Non boolean operand supplied for ! or ~ operator");      throw new ParseException();    }  }  | PrimitiveExpression()}void PrimitiveExpression():{}{  Literal()  | LOOKAHEAD(2)Function()  | <IDENTIFIER>  | <LPAREN>Expression()<RPAREN>}void Function():{  int argCount;  String functionName;}{  <IDENTIFIER>{    functionName = token.image;  }  argCount = Arguments(){    double a = 0.0, b = 0.0, c = 0.0;    if (functionName.equalsIgnoreCase("min")){      if (argCount<2){        System.err.println("Function min() needs two arguments or more!");        throw new ParseException();      }      try {        a = popDouble();        b = popDouble();        a = Math.min(a, b);        if (argCount != 2){          while (argCount != 2){            c = Math.min(a, popDouble());            if (c<a)a = c;            --argCount;          }        }        else {          c = a;        }      }      catch (ClassCastException ex){        throw new ParseException();      }      stack.push(new Double(c));    }    else if (functionName.equalsIgnoreCase("max")){      try {        a = popDouble();        b = popDouble();        a = Math.max(a, b);        if (argCount != 2){          while (argCount != 2){            c = Math.max(a, popDouble());            if (c>a)a = c;            --argCount;          }        }        else {          c = a;        }      }      catch (ClassCastException ex){        //System.err.println("Function min() two "+ 
//"double values as arguments"); 
throw new ParseException();      }      stack.push(new Double(c));    }    else if (functionName.equalsIgnoreCase("sin")){      if (argCount != 1){        System.err.println("Function sin() needs one argument");        throw new ParseException();      }      try {        a = popDouble();      }      catch (ClassCastException ex){        System.err.println("Non string value provided as argument "+"for function exists(). Requires String");        throw new ParseException();      }      stack.push(new Double(Math.sin(a)));    }    else if (functionName.equalsIgnoreCase("cos")){      if (argCount != 1){        System.err.println("Function cos() needs one argument");        throw new ParseException();      }      try {        a = popDouble();      }      catch (ClassCastException ex){        System.err.println("Non string argument for contains(). "+"Requires String");        throw new ParseException();      }      stack.push(new Double(Math.cos(a)));    }  }}//科学计数法后缀
void ScienceAppendix():{  Token x = null;  Token y = null;}{  <SCI>//E | e
(y = <PLUS>  | y = <MINUS>)?//+ -
(x = <INTEGER_LITERAL>){    int eVal = Integer.parseInt(x.image);    double val = popDouble();    if (y == null || y.kind == PLUS){      while (eVal != 0){        val*=10;        --eVal;      }      stack.push(new Double(val));    }    else if (y.kind == MINUS){      while (eVal != 0){        val/=10;        --eVal;      }      stack.push(new Double(val));    }    else throw new ParseException();  }}void Literal():{}{  <INTEGER_LITERAL>{    stack.push(new Double(token.image));  }  (ScienceAppendix())?  | <FLOATING_POINT_LITERAL>{    stack.push(new Double(token.image));  }  (ScienceAppendix())?  | <STRING_LITERAL>{    stack.push(trimQuotes(token.image));  }  | BooleanLiteral()}void BooleanLiteral():{}{  <TRUE>{    stack.push(new Boolean(true));  }  | <FALSE>{    stack.push(new Boolean(false));  }}int Arguments():{  int argCount = 0;}{  <LPAREN>[argCount = ArgumentList()]<RPAREN>{    return argCount;  }}int ArgumentList():{  int argCount = 0;}{  Expression(){    argCount++;  }  (<COMMA>Expression(){    argCount++;  }  )*{    return argCount;  }}
